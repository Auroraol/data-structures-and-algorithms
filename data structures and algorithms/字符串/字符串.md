# 字符串

## 基础知识

见c++总结

#### [1668. 最大重复子字符串](https://leetcode.cn/problems/maximum-repeating-substring/)

给你一个字符串 `sequence` ，如果字符串 `word` 连续重复 `k` 次形成的字符串是 `sequence` 的一个子字符串，那么单词 `word` 的 **重复值为 `k`** 。单词 `word` 的 **最****大重复值** 是单词 `word` 在 `sequence` 中最大的重复值。如果 `word` 不是 `sequence` 的子串，那么重复值 `k` 为 `0` 。

给你一个字符串 `sequence` 和 `word` ，请你返回 **最大重复值 `k`** 。

 

**示例 1：**

```
输入：sequence = "ababc", word = "ab"
输出：2
解释："abab" 是 "ababc" 的子字符串。
```

思路:   利用find函数在sequence中查找word如果能找到，继续增加。否则返回结果。

```c++
class Solution {
public:
    int maxRepeating(string sequence, string word) {
        if (sequence.find(word) == -1) 
            return 0;

        int k = 1;
        string str = word + word;  // 下一次要找到

        while (sequence.find(str) != -1) 
        {
            k++;
            str += word;
        }
        return k;
    }
};
```

#### [1678. 设计 Goal 解析器](https://leetcode.cn/problems/goal-parser-interpretation/)

思路:  利用find函数

```c++
class Solution {
public:
    string interpret(string command) 
    {
        while (command.find("()") != -1) 
            command.replace(command.find("()"), 2, "o");  // 参数2 替换的个数
        while (command.find("(al)") != -1) 
            command.replace(command.find("(al)"), 4, "al");
        return command;
    }
};
```



#### [1768. 交替合并字符串](https://leetcode.cn/problems/merge-strings-alternately/)

```c++
class Solution 
{
public:
    string mergeAlternately(string word1, string word2) 
    {
        int m = word1.size(), n = word2.size();
        string ans;
        for (int i = 0; i < m || i < n; ++i) 
        {
            // 依次取出拼接
            if (i < m) 
                ans += word1[i];
            if (i < n) 
                ans += word2[i];
        }
        return ans;
    }
};
```



### stringstream格式化字符串

#### [290. 单词规律](https://leetcode.cn/problems/word-pattern/)

思路:  stringstream格式化字符串

```c++
class Solution 
{
public:
    bool wordPattern(string pattern, string s) 
    {
        vector<string> str;
        stringstream iss(s); //直接截取字符串的函数
        string word;
        while(iss>>word) 
            str.push_back(word); //把字符串放入
        if(str.size()!=pattern.size()) 
            return false; //判断是不是满射
        unordered_map<char,string>pw; //判断是不是单射
        unordered_map<string,char>wp; //判断是不是映射
        for(int i = 0;i<pattern.size();i++)
        {
            auto a = pattern[i];
            auto b = str[i];
            if(pw.count(a)&&pw[a]!=b) return false; //如果存在该字母对应的字符串不一致，则返回false
            pw[a] = b; //存入哈希表
            if(wp.count(b)&&wp[b]!=a) 
                return false; //如果存在该字符串对应的单词有多个（不一致） ，返回false
            wp[b] = a; //存入哈希表
        }
        return true;
    }
};
```

#### **[1507. 转变日期格式](https://leetcode.cn/problems/reformat-date/)**

思路:  stringstream格式化字符串

```c++
class Solution 
{
public:
    string reformatDate(string date) 
    {   // 请你将字符串转变为 YYYY-MM-DD 的格式
        // 字符串 date ，它的格式为 Day Month Year
        unordered_map<string, string> mon = {
            {"Jan", "01"},
            {"Feb", "02"},
            {"Mar", "03"},
            {"Apr", "04"},
            {"May", "05"},
            {"Jun", "06"},
            {"Jul", "07"},
            {"Aug", "08"},
            {"Sep", "09"},
            {"Oct", "10"},
            {"Nov", "11"},
            {"Dec", "12"}
        };
        string year, month, day;
        stringstream word(date);
        word >> day >> month >> year;
        month = mon[month];
        day.pop_back();
        day.pop_back();
         if (day.size() == 1) {
            day = "0" + day;
        }
        return year + "-" + month + "-" + day;
    }
};
```

[290. 单词规律](https://leetcode.cn/problems/word-pattern/)

### 空格处理

#### [05.替换空格](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/)

**数组填充类的问题: **

+ 都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。

这么做有两个好处：

1. 不用申请新数组。
2. 从后向前填充元素，避免了从前先后填充元素要来的 每次添加元素都要将添加元素之后的所有元素向后移动。

```c++
class Solution {
public:
    string replaceSpace(string s) {
        int count = 0; // 统计空格的个数
        int sOldSize = s.size();
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == ' ') {
                count++;
            }
        }
        // 扩充字符串.assetss的大小，也就是每个空格替换成"%20"之后的大小
        s.resize(s.size() + count * 2);
        int sNewSize = s.size();
        // 从后先前将空格替换为"%20"
        for (int i = sNewSize - 1, j = sOldSize - 1; j < i; i--, j--) {
            if (s[j] != ' ') {
                s[i] = s[j];
            } else {
                s[i] = '0';
                s[i - 1] = '2';
                s[i - 2] = '%';
                i -= 2;
            }
        }
        return s;
    }
};
```

#### [151.翻转字符串.assets里的单词](https://leetcode-cn.com/problems/reverse-words-in-a-string/)

**示例 3：**

```
输入: " a good  example "
输出: "example good a"
```

思路：

- 移除多余空格
- 将整个字符串.assets反转
- 将每个单词反转

```c++
class Solution
{
public:

    // 反转字符串s中左闭又闭的区间[start, end]
    void reverse(string& s, int start, int end) 
    {
        for (int i = start, j = end; i < j; i++, j--) 
        {
            swap(s[i], s[j]);
        }
    }

    void removeExtraSpaces(string& s)
    {
        int slowIndex = 0, fastIndex = 0;
        // 去前空号
        while (s.size() > 0 && fastIndex < s.size() && s[fastIndex] == ' ')
        {
            fastIndex++;
        }
        // 去内部空号
        for (; fastIndex < s.size(); fastIndex++)
        {
            // 需要保留一个空号
            if (fastIndex > 0 && s[fastIndex] == ' ' 
                && s[fastIndex - 1] == s[fastIndex])
                continue;
            s[slowIndex++] = s[fastIndex];
        }
        // 去末尾空号
        if (slowIndex > 0 && s[slowIndex - 1] == ' ')
            s.resize(slowIndex - 1);
        else 
            s.resize(slowIndex);

    }

   string reverseWords(string s) 
   {
        removeExtraSpaces(s); // 去掉冗余空格
        reverse(s, 0, s.size() - 1); // 将字符串全部反转
        int start = 0; // 反转的单词在字符串里起始位置
        int end = 0; // 反转的单词在字符串里终止位置
        bool entry = false; // 标记枚举字符串的过程中是否已经进入了单词区间
        for (int i = 0; i < s.size(); i++) 
        { // 开始反转单词
            if (!entry) 
            {
                start = i; // 确定单词起始位置
                entry = true; // 进入单词区间
            }
            // 单词后面有空格的情况，空格就是分词符
            if (entry && s[i] == ' ' && s[i - 1] != ' ') 
            {
                end = i - 1; // 确定单词终止位置
                entry = false; // 结束单词区间
                reverse(s, start, end);
            }
                // 最后一个结尾单词之后没有空格的情况
            if (entry && (i == (s.size() - 1)) && s[i] != ' ' ) 
            {
                end = i;// 确定单词终止位置
                entry = false; // 结束单词区间
                reverse(s, start, end);
            }
        }
        return s;
    }

};
```





#### [792. 匹配子序列的单词数](https://leetcode.cn/problems/number-of-matching-subsequences/)

给定字符串 s 和字符串数组 words, 返回  words[i] 中是s的子序列的单词个数 。

字符串的 子序列 是从原始字符串中生成的新字符串，可以从中删去一些字符(可以是none)，而不改变其余字符的相对顺序。

例如， “ace” 是 “abcde” 的子序列。


示例 1:

```
输入: s = "abcde", words = ["a","bb","acd","ace"]
输出: 3
解释: 有三个是 s 的子序列的单词: "a", "acd", "ace"。
```

代码:

find_first_of()

```c++
class Solution {
public:
    int numMatchingSubseq(string s, vector<string>& words) {
        int n = (int)s.size();

        int res = 0;
        for (string word: words)
        {
            bool ok = true;
            if ((int)word.size() > n)
            {
                continue;
            }
            int curIdx = -1;
            for (char c: word)
            {
                // curIdx + 1 从哪里开始找
                int j = s.find_first_of(c, curIdx + 1); //下一次只能往后找
                if (j == -1)
                {
                    ok = false;
                    break;
                }
                curIdx = j;
            }
            
            if (ok == true){
                res ++;
            }
        }

        return res;
    }
};
```



Find()

```c++
class Solution {
public:
    int numMatchingSubseq(string s, vector<string>& words) {
        int n = (int)s.size();

        int res = 0;
        for (string word: words)
        {
            bool ok = true;
            if ((int)word.size() > n)
            {
                continue;
            }
            int curIdx = -1;
            for (char c: word)
            {
                // curIdx + 1 从哪里开始找
                int j = s.find(c, curIdx + 1); //下一次只能往后找
                if (j == -1)
                {
                    ok = false;
                    break;
                }
                curIdx = j;
            }
            
            if (ok == true){
                res ++;
            }
        }

        return res;
    }
};
```



#### [884. 两句话中的不常见单词](https://leetcode.cn/problems/uncommon-words-from-two-sentences/)



**句子** 是一串由空格分隔的单词。每个 **单词** 仅由小写字母组成。

如果某个单词在其中一个句子中恰好出现一次，在另一个句子中却 **没有出现** ，那么这个单词就是 **不常见的** 。

给你两个 **句子** `s1` 和 `s2` ，返回所有 **不常用单词** 的列表。返回列表中单词可以按 **任意顺序** 组织。

**示例 1：**

```
输入：s1 = "this apple is sweet", s2 = "this apple is sour"
输出：["sweet","sour"]
```

```C++
class Solution {
public:
    vector<string> uncommonFromSentences(string s1, string s2) {
        vector<string> ans;
        unordered_map<string, int> strMap;
        stringstream iss(s1);
        string word;
        while(iss >> word)
        {
            strMap[word]++;
        }

        stringstream iss2(s2);
        while(iss2 >> word)
        {
            strMap[word]++;
        }

       for (auto [word,cnt] : strMap)
       {
            if (cnt == 1)
                ans.push_back(word);
       }

        return ans;
    }
};
```



## [821. 字符的最短距离](https://leetcode.cn/problems/shortest-distance-to-a-character/)

给你一个字符串 `s` 和一个字符 `c` ，且 `c` 是 `s` 中出现过的字符。

返回一个整数数组 `answer` ，其中 `answer.length == s.length` 且 `answer[i]` 是 `s` 中从下标 `i` 到离它 **最近** 的字符 `c` 的 **距离** 。

两个下标 `i` 和 `j` 之间的 **距离** 为 `abs(i - j)` ，其中 `abs` 是绝对值函数。

 

**示例 1：**

```
输入：s = "loveleetcode", c = "e"
输出：[3,2,1,0,1,0,0,1,2,2,1,0]
解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。
距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。
距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。
对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。
距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 
```



前后遍历

```c++
class Solution {
public:
    vector<int> shortestToChar(string s, char c) {

        // 例子: etcoejj
        int len = s.size();
        vector<int> result(len, len);
        int lastC = -len; 
        for (int i = 0; i < len; i++)
        {
            if (s[i] == c)
                lastC = i;
            result[i] = min(result[i], abs(i - lastC));
        }  

        for (int i =  lastC - 1; i >= 0; i--)
        {
            if (s[i] == c)
                lastC = i;
            result[i] = min(result[i], abs(i - lastC));
        }
    
        return result;
    }
};
```

## [830. 较大分组的位置](https://leetcode.cn/problems/positions-of-large-groups/)

在一个由小写字母构成的字符串 `s` 中，包含由一些连续的相同字符所构成的分组。

例如，在字符串 `s = "abbxxxxzyy"` 中，就含有 `"a"`, `"bb"`, `"xxxx"`, `"z"` 和 `"yy"` 这样的一些分组。

分组可以用区间 `[start, end]` 表示，其中 `start` 和 `end` 分别表示该分组的起始和终止位置的下标。上例中的 `"xxxx"` 分组用区间表示为 `[3,6]` 。

我们称所有包含大于或等于三个连续字符的分组为 **较大分组** 。

找到每一个 **较大分组** 的区间，**按起始位置下标递增顺序排序后**，返回结果。

 

**示例 1：**

```
输入：s = "abbxxxxzzy"
输出：[[3,6]]
解释："xxxx" 是一个起始于 3 且终止于 6 的较大分组。
```



```c++
class Solution {
public:
    vector<vector<int>> largeGroupPositions(string s) {
        if (s.size() < 3) 
            return {};

        vector<vector<int>> res;
        int N = s.size();
        int count = 1;
        for (int i = 1; i < N; i++) 
        {
            if (s[i] == s[i - 1]) 
            {
                count++;
            } 
            else
            {
                if (count >= 3)
                {
                    res.push_back({i - count, i - 1});
                }
                count = 1;
            }
        }

        // 最后
        if (count >= 3) 
        {
            res.push_back({N - count, N - 1});
        }

        return res;
    }

};
```

## [859. 亲密字符串](https://leetcode.cn/problems/buddy-strings/)

给你两个字符串 `s` 和 `goal` ，只要我们可以通过交换 `s` 中的两个字母得到与 `goal` 相等的结果，就返回 `true` ；否则返回 `false` 。

交换字母的定义是：取两个下标 `i` 和 `j` （下标从 `0` 开始）且满足 `i != j` ，接着交换 `s[i]` 和 `s[j]` 处的字符。

- 例如，在 `"abcd"` 中交换下标 `0` 和下标 `2` 的元素可以生成 `"cbad"` 。

 

**示例 1：**

```
输入：s = "ab", goal = "ba"
输出：true
解释：你可以交换 s[0] = 'a' 和 s[1] = 'b' 生成 "ba"，此时 s 和 goal 相等。
```





```c++
class Solution {
public:
    bool buddyStrings(string s, string goal) {
        /**
        返回true情况： 
        大条件：len(A) == len(B) 
        一：有两个不同地方(i,j)，且A[i]=B[j],A[j]=B[i] 
        二：完全相同，一个数组中存在重复数字
        **/

        if(s.size() != goal.size()) 
            return false;

        vector<int> vt;
        unordered_map<char, int> hash;
        int maxCount = 0;
        for(int i = 0; i < s.size(); i++) 
        {
            hash[s[i]]++;
            maxCount = max(maxCount, hash[s[i]]);
            //保存不同的两个位置
            if(s[i] != goal[i]) 
                vt.push_back(i); 

        }

        //完全相同
        if(vt.empty()) 
            return maxCount >= 2;

        //有两个不同地方
        if (vt.size()==2 && s[vt[0]] == goal[vt[1]] 
            && s[vt[1]] == goal[vt[0]])
        {
            return true;
        }

        return false;
    }
};
```



##  常用的大小写转换

 **string**

如果使用[string类](https://so.csdn.net/so/search?q=string类&spm=1001.2101.3001.7020)，可以使用#include <algorithm>里的如下方法进行大小写转换；

```c++
transform(str.begin(),str.end(),str.begin(), ::tolower);
```

例子

```cpp
string str;
cin>>str;
///转小写
transform(str.begin(),str.end(),str.begin(),::tolower);
cout<<"转化为小写后为："<<str<<endl;
transform(str.begin(),str.end(),str.begin(),::toupper);
cout<<"转化为大写后为："<<str<<endl;
```

ps: **是::tolower，不是::tolower()**

 **char**

**如果用char数组，可以用到下面的内容实现转换**

```c
C++中与字符判断有关的内置函数
isalpha(char c)判断字符c是否是字母，如果是返回true,反之false。
islower(char c)判断字符c是否是小写字母，如果是返回true,反之false。
isupper(char c)判断字符c是否是大写字母，如果是返回true,反之false。
isdigit(char c)判断字符c是否是数字，如果是返回true,反之false。
isalnum(char c)判断字符c是否是字母或数字，如果是返回true,反之false。
tolower(char c)将字符c转换为小写字母。如果字符c无法转换为小写字母，返回字符c。
toupper(char c)将字符c转换为大写字母。如果字符c无法转换为大写字母，返回字符c。
```

忽略标点

```c++
string removePunctuation(string& str) {
    string processedString;

    for (char c : str) {
        if (!ispunct(c))  {
            //默认情况下，标点符号为 !"#$%&'()*+,-./:;?@[\]^_`{|}~。
            processedString += c;
        }
    }

    return processedString;
}
```

### [917. 仅仅反转字母](https://leetcode.cn/problems/reverse-only-letters/)

给你一个字符串 `s` ，根据下述规则反转字符串：

- 所有非英文字母保留在原有位置。
- 所有英文字母（小写或大写）位置反转。

返回反转后的 `s` *。*

 

**示例 1：**

```
输入：s = "Test1ng-Leet=code-Q!"
输出："Qedo1ct-eeLg=ntse-T!"
```



```c++
class Solution {
public:
    string reverseOnlyLetters(string s) {
        int left = 0;
        int right = s.size() - 1;

        while(left < right)
        {
            if (!isalpha(s[left]))
                left++;
            if(!isalpha(s[right]))
                right--;
            if(isalpha(s[left]) && isalpha(s[right]))
                swap(s[left++],s[right--]);
        }

        return s;
    }
};
```

## erase(), substr(), append() 和 find()

### find(str)

find() – 在字符串中查找字符串第一次出现的位置   **返回开始的索引**

```c++
str1.find(str2);           // 从串str1中查找时str2，返回str2中首个字符在str1中的地址

str1.find(str2, 5);        //  从str1的第5个字符开始查找str2

str1.find("usage");      //  如果usage在str1中查找到，返回u在str1中的位置

str1.find("o");           //  查找字符o并返回地址

str1.find("of big",2, 2);    //  从str1中的第二个字符开始查找of big的前两个字符
```

find_first_of()函数正向查找在原字符串中第一个与指定字符串（或字符）中的某个字符匹配的字符，返回它的位置。若查找失败，则返回npos。（npos定义为保证大于任何有效下标的值。）

如果在一个字符串str1中查找另一个字符串str2，如果str1中含有str2中的任何字符，则就会查找成功.

```c++
比如：
string str1("I am change");
string  str2("about");
int k=str1.find_first_of(str2);    //k返回的值是about这5个字符中任何一个首次在str1中出现的位置；
```

find_last_of()函数逆向查找在原字符串中最后一个与指定字符串（或字符）中的某个字符匹配的字符，返回它的位置。若查找失败，则返回npos。（npos定义为保证大于任何有效下标的值。）



find() 正向查找要匹配字符串的第一个字符出现的位置

rfind()反向查找要匹配的字符串的第一个字符出现的位置

对于上面两个函数，若查找失败 则会返回一个特殊标记npos，一般写做string::npos

find_first_of()正向查找要匹配的字符串的第一个字符出现的位置

find_last_of() 反向查找要匹配的字符串的最后一个字符出现的位置



```c++
int main()
{
    string words "mass as";
    string c="as”;
    cout <words.find first_of(c)<""<<words.find_last of(c)<<endl
    cout <words.find(c)<<""<<words.rfind(c);
    return 0;
}

//
1  6
1  5    
```



​     (1). **可以查找  子字符串**

```c++
string name("dsfAnna11qijiashe");
int pos = name.find("Anna11");

if(pos == string::npos)     
    cout<<"Anna not found!\n";
else
    cout << "找到了在" << pos;

// 结果
找到了在3
```

+ 注意:   ==**没有  返回的是 -1; 或者 string::npos  并 不是 0**==
+ 判断都用 != -1  没找到     != 0 没找到前缀

```c++
string str("hello world");

string::size pos=str.find_first_of("h");   //

if(pos != string::npos)  
{
	....// 查找到了
} //没有 find返回string::npos
```

-------------

​      (2). **子串  是由主串字符构成的**

```c++
bool b1 = true;
......
for (auto c: word) 
{
    b1 &= m1[c];    //m1是 子串的hash,  hash没有 返回值为null
}
..........
if (b1)   // 子串的字符是主串构成
    ans.push_back(word);
```

### substr(i, j+1 -i)

**substr()  – 返回某个范围子字符串**  //    (起始的索引,  个数)

一个参数就表示到末尾   t=   substr(l)*// 从l到len;*  

```c++
#include <iostream>
#include <string>
using namespace std;

int main() {
    string str = "Hello, World!";
    int i = 2;
    int j = 6;

    string sub = str.substr(i, j+1 -i); // //索引[i,j] //到末尾[i,size -i]这里的size-i可以省略 //截取末尾一个元素[0, size-1] 

    cout << sub << endl;

    return 0;
}
```

```c++
举一个例子
string str = "codoncodon";
所以提取前三个字符，可以用 string str1 = str.substr(0,3);
提取4-6 string str2 = str.substr(4,3);
然后7-9 string str3 = str.substr(7,3);
//此函数需要注意一点是函数的第二个参数为字符数目，而不是下标值，  
```

**跳过 i, j的内容**

```c++
#include <iostream>
#include <string>
using namespace std;

int main() {
    string str = "Hello, World!";
    int i = 2;
    int j = 6;

    string skipped = str.substr(0, i) + str.substr(j+1);// 跳过[i,j] // 参数是末尾可以省略

    cout << skipped << endl; //HeWorld!

    return 0;
}
```

### erase(i, j+1 -i)

**erase  (int pos，int n = npos);**    //删除从Pos开始的n个字符

```c++
#include <iostream>
#include <string>
using namespace std;

int main() {
    string str = "Hello, World!";
    int i = 2;
    int j = 6;

    str.erase(i, j+1 -i); //索引[i,j]//到末尾[i,size -i] //参数是末尾可以省略 //删除i开始的n个元素[i, n]

    cout << str << endl; //Helo, World!

    return 0;
}

```

例子

```c++
// 去除字符串前后空格
void trim(string& s)
{
    if (s.empty())
        return;
    s.erase(0, s.find_first_not_of(" "));  //查找第一个不是空格的字符的位置并擦除该位置之前的所有字符来删除任何前导空格
    s.erase(s.find_last_not_of(" ") + 1);  //查找最后一个不是空格的字符的位置并擦除该位置之后的所有字符来删除任何尾随空格
}  
```

### append(str2, i, j+1 -i)

**append()函数**

```c++
#include <iostream>
#include <string>
using namespace std;

int main() {
    string str1 = "Hello, ";
    string str2 = "World!";
    int i = 2;
    int j = 4;

    str1.append(str2, i, j-i+1);  //索引[i,j]//到末尾[i,size -i]

    cout << str1 << endl;  //Hello, rld!

    return 0;
}
```

### [14. 最长公共前缀](https://leetcode.cn/problems/longest-common-prefix/)

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 `""`。

**示例 1：**

```
输入：strs = ["flower","flow","flight"]
输出："fl"
```

```c++
class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        /*
        1.为空，res = ""，不为空，res = strs[0]; 
        2.开始遍历 
        3.s.find(res) != 0不是其前缀，开始减去res的最后一个字符

        */
        string res = strs.empty() ? "" : strs[0]; 
        for (string s : strs) 
        {
            while (s.find(res) != 0)  //没找到了前缀
                res = res.substr(0, res.length() - 1); //减去res的最后一个字符
        }

        return res;
    }
};
```

### [1455. 检查单词是否为句中其他单词的前缀](https://leetcode.cn/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/)

给你一个字符串 `sentence` 作为句子并指定检索词为 `searchWord` ，其中句子由若干用 **单个空格** 分隔的单词组成。请你检查检索词 `searchWord` 是否为句子 `sentence` 中任意单词的前缀。

如果 `searchWord` 是某一个单词的前缀，则返回句子 `sentence` 中该单词所对应的下标（**下标从 1 开始**）。如果 `searchWord` 是多个单词的前缀，则返回匹配的第一个单词的下标（**最小下标**）。如果 `searchWord` 不是任何单词的前缀，则返回 `-1` 。

字符串 `s` 的 **前缀** 是 `s` 的任何前导连续子字符串。

 

**示例 1：**

```
输入：sentence = "i love eating burger", searchWord = "burg"
输出：4
解释："burg" 是 "burger" 的前缀，而 "burger" 是句子中第 4 个单词。
```

```c++
class Solution {
public:
    int isPrefixOfWord(string sentence, string searchWord) {
        stringstream sst(sentence);
        string word;
        int count = 1;
        while (sst >> word)
        {
            if (word.find(searchWord) == 0)  //前缀
               return count; 
            count++;
        }

        return -1;

    }
};
```



### [1408. 数组中的字符串匹配](https://leetcode.cn/problems/string-matching-in-an-array/)

给你一个字符串数组 `words` ，数组中的每个字符串都可以看作是一个单词。请你按 **任意** 顺序返回 `words` 中是其他单词的子字符串的所有单词。

如果你可以删除 `words[j]` 最左侧和/或最右侧的若干字符得到 `words[i]` ，那么字符串 `words[i]` 就是 `words[j]` 的一个子字符串。

 

**示例 1：**

```
输入：words = ["mass","as","hero","superhero"]
输出：["as","hero"]
解释："as" 是 "mass" 的子字符串，"hero" 是 "superhero" 的子字符串。
["hero","as"] 也是有效的答案。
```

```c++
class Solution {
public:
    vector<string> stringMatching(vector<string>& words) {
        vector<string> ret;
        for (int i = 0; i < words.size(); i++) 
        {
            for (int j = 0; j < words.size(); j++)
            {
                // i != j跳过自身
                if (i != j && words[j].find(words[i]) != string::npos) 
                {
                    ret.push_back(words[i]);
                    break;
                }
            }
        }
        
        return ret;
    }
};
```



## 正则

### [2047. 句子中的有效单词数](https://leetcode.cn/problems/number-of-valid-words-in-a-sentence/)

句子仅由小写字母（`'a'` 到 `'z'`）、数字（`'0'` 到 `'9'`）、连字符（`'-'`）、标点符号（`'!'`、`'.'` 和 `','`）以及空格（`' '`）组成。每个句子可以根据空格分解成 **一个或者多个 token** ，这些 token 之间由一个或者多个空格 `' '` 分隔。

如果一个 token 同时满足下述条件，则认为这个 token 是一个有效单词：

- 仅由小写字母、连字符和/或标点（不含数字）组成。
- **至多一个** 连字符 `'-'` 。如果存在，连字符两侧应当都存在小写字母（`"a-b"` 是一个有效单词，但 `"-ab"` 和 `"ab-"` 不是有效单词）。
- **至多一个** 标点符号。如果存在，标点符号应当位于 token 的 **末尾** 。

这里给出几个有效单词的例子：`"a-b."`、`"afad"`、`"ba-c"`、`"a!"` 和 `"!"` 。

给你一个字符串 `sentence` ，请你找出并返回 `sentence` 中 **有效单词的数目** 。

 

**示例 1：**

```
输入：sentence = "cat and  dog"
输出：3
解释：句子中的有效单词是 "cat"、"and" 和 "dog"
```



```c++
class Solution {
public:
    int countValidWords(string sentence) {
        string word;
        regex r("[a-z]*([a-z]-[a-z])?[a-z]*[!.,]?");
        int cent=0;
        istringstream iss(sentence);
        while(iss >> word)
        {
            if(regex_match(word,r)) 
                cent++;
        }
        return cent;
    }
};
```

## 状态位

### [929. 独特的电子邮件地址](https://leetcode.cn/problems/unique-email-addresses/)

每个 **有效电子邮件地址** 都由一个 **本地名** 和一个 **域名** 组成，以 `'@'` 符号分隔。除小写字母之外，电子邮件地址还可以含有一个或多个 `'.'` 或 `'+'` 。

- 例如，在 `alice@leetcode.com`中， `alice` 是 **本地名** ，而 `leetcode.com` 是 **域名** 。

如果在电子邮件地址的 **本地名** 部分中的某些字符之间添加句点（`'.'`），则发往那里的邮件将会转发到本地名中没有点的同一地址。请注意，此规则 **不适用于域名** 。

- 例如，`"alice.z@leetcode.com”` 和 `“alicez@leetcode.com”` 会转发到同一电子邮件地址。

如果在 **本地名** 中添加加号（`'+'`），则会忽略第一个加号后面的所有内容。这允许过滤某些电子邮件。同样，此规则 **不适用于域名** 。

- 例如 `m.y+name@email.com` 将转发到 `my@email.com`。

可以同时使用这两个规则。

给你一个字符串数组 `emails`，我们会向每个 `emails[i]` 发送一封电子邮件。返回实际收到邮件的不同地址数目。

 

**示例 1：**

```
输入：emails = ["test.email+alex@leetcode.com","test.e.mail+bob.cathy@leetcode.com","testemail+david@lee.tcode.com"]
输出：2
解释：实际收到邮件的是 "testemail@leetcode.com" 和 "testemail@lee.tcode.com"。
```

方法1

```c++
class Solution {
public:
    int numUniqueEmails(vector<string>& emails) {
        set<string> ans;
        for(auto email : emails)
        {
            string temp;
            int flag = 1;      
            int lenght = email.size(); 
            for(int j = 0; j < lenght; j++)
            {
                if(email[j]=='+')         //遇到+号之后，跳过
                    flag=0;
                else if(email[j]=='@')    //遇到@之后，temp追加之后的元素
                {
                    temp += email.substr(j, lenght -j);
                    break;
                }

                switch(flag)
                {
                case 1:
                    if(email[j] != '.')
                        temp+=email[j];
                    break;
                case 0:
                    break; //跳过
                }

            }
            ans.insert(temp);  
        }
        return ans.size();
    }
};
```

方法2

```c++
class Solution {
public:
    int numUniqueEmails(vector<string>& emails) {
        set<string> ans;
    

        for(auto email : emails)
        {
            string skipped;
            int i = email.find('+');
            int j = email.find('@');
            if (i != -1 )  //有'+'
                skipped = email.substr(0, i) + email.substr(j);
            else
               skipped = email;


            for (int i = 0; i < skipped.size(); i++)
            {
                if (skipped[i] == '.')
                    skipped.erase(i, 1);
                else if (skipped[i] == '@')
                    break;
            }

            ans.insert(skipped);  
        }
        return ans.size();
    }
};
```



##  字符串转成日期

### std::get_time()函数

它用于从应用中输入流的字符中提取字符，并将它们解析为参数`fmt`中指定的时间和日期信息。获得的数据存储在`tmb`指向的`struct tm`对象。 //更多请阅读：https://www.yiibai.com/cpp_standard_library/cpp_get_time.html 

常用

```
时:分:秒 %H:%M:%S        %T (C++11标准)
年-月-日 %Y:%m:%d        %F (C++11标准)
当地时间标准 %X
十二小时制 %I (%p <==> a.m|p.m 或者当地写法)
当期日期标准 %x
一年的第几天 %j
第几周 %U (00-53) 周日为第一天
%W (00-53) 周一为第一天
%V (01-53) 周一为第一天 (C++11标准)
周一为星期的第一天
每年的第一星期为包含1月4号的那个星期.
或者包含第一个星期四那个星期
星期几 %w (0-6) %u(1-7)(C++11标准)
星期几 %a 单词简写 %A 单词全称 (当地写法)
```

例子

```c++
#include <iostream>     
#include <iomanip>      
#include <ctime>        

int main () {
  struct std::tm when;
  std::cout << "Please, enter the time: ";
  std::cin >> std::get_time(&when,"%R");   

  if (std::cin.fail()) std::cout << "Error reading time/n";
  else {
    std::cout << "The time entered is: ";
    std::cout << when.tm_hour << " hours and " << when.tm_min << " minutes/n";
  }

  return 0;
}
```

####  mktime

**函数原型**

```c
time_t mktime(struct tm *)
```

**其中的 tm 结构体定义如下：**

```c
struct tm {
int tm_sec; /* 秒 – 取值区间为[0,59] */
int tm_min; /* 分 - 取值区间为[0,59] */
int tm_hour; /* 时 - 取值区间为[0,23] */
int tm_mday; /* 一个月中的日期 - 取值区间为[1,31] */
int tm_mon; /* 月份（从一月开始，0代表一月） - 取值区间为[0,11] */
int tm_year; /* 年份，其值等于实际年份减去1900 */
int tm_wday; /* 星期 – 取值区间为[0,6]，其中0代表星期天，1代表星期一，以此类推 */
int tm_yday; /* 从每年的1月1日开始的天数 – 取值区间为[0,365]，其中0代表1月1日，1代表1月2日，以此类推 */
int tm_isdst; /* 夏令时标识符，实行夏令时的时候，tm_isdst为正。不实行夏令时的进候，tm_isdst为0；不了解情况时，tm_isdst()为负。*/
};
```

### [1154. 一年中的第几天](https://leetcode.cn/problems/day-of-the-year/)

给你一个字符串 `date` ，按 `YYYY-MM-DD` 格式表示一个 [现行公元纪年法](https://baike.baidu.com/item/公元/17855) 日期。返回该日期是当年的第几天。

 

**示例 1：**

```
输入：date = "2019-01-09"
输出：9
解释：给定日期是2019年的第九天。
```

```c++
class Solution {
public:
    int dayOfYear(string date) {
        tm t{};
        stringstream iss(date);
        iss >> get_time(&t, "%Y-%m-%d");
        mktime(&t);
        return t.tm_yday + 1;
    }
};
```





## [1021. 删除最外层的括号](https://leetcode.cn/problems/remove-outermost-parentheses/)

有效括号字符串为空 `""`、`"(" + A + ")"` 或 `A + B` ，其中 `A` 和 `B` 都是有效的括号字符串，`+` 代表字符串的连接。

- 例如，`""`，`"()"`，`"(())()"` 和 `"(()(()))"` 都是有效的括号字符串。

如果有效字符串 `s` 非空，且不存在将其拆分为 `s = A + B` 的方法，我们称其为**原语（primitive）**，其中 `A` 和 `B` 都是非空有效括号字符串。

给出一个非空有效字符串 `s`，考虑将其进行原语化分解，使得：`s = P_1 + P_2 + ... + P_k`，其中 `P_i` 是有效括号字符串原语。

对 `s` 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 `s` 。

 

**示例 1：**

```
输入：s = "(()())(())"
输出："()()()"
解释：
输入字符串为 "(()())(())"，原语化分解得到 "(()())" + "(())"，
删除每个部分中的最外层括号后得到 "()()" + "()" = "()()()"。
```

```
class Solution {
public:
    string removeOuterParentheses(string S) {
        //最外面的左括号跳过，L初始为1；当右括号数量等于左括号数量的位置就是最外面的右括号
        int L=1;
        int R=0;
        string ans;

        for(int i=1;i<S.size();i++)
        {
            if(S[i]=='(')
                L++;
            else 
                R++;

            if(R != L)
                ans.push_back(S[i]);
            else 
            {
                i++;
                L=1;
                R=0;
            }
        }
        
        return ans;
    }
};
```







```
class Solution {
public:
    vector<int> shuffle(vector<int>& nums, int n) {
        vector<int> res(2 * n, 0);
        for (int i = 0; i < n; i ++) res[2 * i] = nums[i];  
        for (int i = 0; i < n; i ++) res[2 * i + 1] = nums[n + i];
        return res;
    }
};
```

