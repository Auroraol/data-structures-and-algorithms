

# 链表的种类

## 单链表

单链表中的指针域只能指向节点的下一个节点

## 双链表

双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点
双链表既可以向前查询也可以向后查询.
如图所示

![image-20221031195539479](链表.assets/image-20221031195539479.png)

## 循环链表

循环链表，顾名思义，就是链表首尾相连。

循环链表可以用来解决约瑟夫环问题。

<img src="链表.assets/image-20221031195657823.png" alt="image-20221031195657823" style="zoom:67%;" />

# 链表定义

c++:

```c++
// 单链表
struct ListNode 
{
    int val;          // 节点上存储的元素
    ListNode *next;  // 指向下一个节点的指针
    ListNode(int x) : val(x), next(NULL) {}  // 节点的构造函数
};
```

c语言:

```c
typedef struct LinkNode
{
	int val;
	struct LinkNode* next;
}LinkNode;
```



# 链头创建

链接接的入口节点称为链表的头结点也就是head
如图所示:![image-20221031195426671](链表.assets/image-20221031195426671.png)



**个人习惯使用哨兵节点:   **

```c++
LinkNode* dummyHead = new LinkNode(0); // 如果没有创建哨兵就这样创建
LinkNode* cur = dummyHead;

// cur->next  使用
// dummyHead->next 为真的头节点
```



# 链表实现

**c++:**

```c++
#include <iostream>

using namespace std;


struct LinkNode
{
	int val;
	LinkNode* next;
	LinkNode(int val) : val(val) { next = nullptr; }
};


class MyLinkedList
{
private:
	LinkNode* dummyHead;
	int size;
public:
	MyLinkedList()
	{
		dummyHead = new LinkNode(0);  // 创建哨兵节点  // 一般设置成0或者-1
		size = 0;
	}
	
    // 析构
	~MyLinkedList()
	{
		LinkNode* freeNode;
		while (dummyHead != NULL)
		{
            freeNode = dummyHead;
			dummyHead = dummyHead->next;
			delete freeNode;
		}
	}

	// 头创建
	void addHead(int data)
	{
		LinkNode* newNode = new LinkNode(data); // 创建新节点
		newNode->next = dummyHead->next;  // 相当于  newNode->next = head; //指针域去指向head指针
		dummyHead->next = newNode;
		size++;
	}

	// 尾创建
	void addTail(int data)
	{
		LinkNode* cur = dummyHead;   //cur成为前驱节点 //真链表的头节点就dummyHead->next, 这个可以保持头不变
		LinkNode* newNode = new LinkNode(data); // 创建一个节点
		while (cur->next)
		{
			cur = cur->next;
		}
		cur->next = newNode;
		size++;
	}

	// 插入
	void insert(int data, int index)
	{
		if (index > size)
			return;
		LinkNode* cur = dummyHead;
		LinkNode* newNode = new LinkNode(data);
		while (index--)
		{
			cur = cur->next;
		}
		//插入
		newNode->next = cur->next;
		cur->next = newNode;
		size++;
	}


	// 删除指定元素
	void deleteVal(int data)
	{
		/*if (search(data) == 0)
			return;*/
		LinkNode* cur = dummyHead;
		while (cur->next)
		{
			if (cur->next->val == data)
				break;
			cur = cur->next;
		}
		LinkNode* temp = cur->next;
		cur->next = cur->next->next;
		delete temp;
		size--;
	}

	// 删除指定索引
	void deleteInd(int index)
	{
		if (index >= size || index < 0)
			return;
		LinkNode* cur = dummyHead;
		while (index--)
		{
			cur = cur->next;
		}
		LinkNode* temp = cur->next;   //第 index个节点并不是ndex的
		cur->next = cur->next->next;
		delete temp;
		size--;
	}

	// 显示
	void show() const
	{
		LinkNode* cur = dummyHead;
		while (cur->next)
		{
			cout << cur->next->val;
			cur = cur->next;
		}
		cout << endl;
	}
};

int main(void)
{
	return 0;
}
```

**c语言:**

```c
#pragma once
#include <stdbool.h>

typedef int Data;

// 定义节点结构
typedef struct linkNode
{
	Data data;
	struct linkNode* next;

}linkNode;

// 创建链表
linkNode* createList();

// 创建节点
linkNode* createNode(Data val);

// 插入
//头插入
void pushfront(linkNode* list, Data val);
//尾插入
void push_back(linkNode* list, Data val);
//指定位置插入(下标)
void insert_pos(linkNode* list, int pos, Data val);
//指定位置插入(在指定元素之后)
void insert_item(linkNode* list, linkNode* item, Data val);
// 查找元素
linkNode* find(linkNode* list, Data data);


// 删除
//头删
void pop_front(linkNode* list);
//尾删
void pop_back(linkNode* list);
//指定元素删除
void removeOne(linkNode* list, Data val);
void removeA1l(linkNode* list, Data val);  // 删除所有val
bool isempty(linkNode* list);

// 遍历
void show_list(linkNode* list);
```

```c
#include "LinkList.h"
#include <stdio.h>
#include <malloc.h>
#include <string.h>

linkNode* createList()
{
    //哨兵节点  //先new一个节点充当哨兵节点 //也可以不做这个函数但是在操作函数实现是每个单独去设置哨兵节点,麻烦 
	linkNode* head = malloc(sizeof(linkNode));   
	if (!head)                     
	{
		printf("head malloc failed");
		return NULL;
	}
	memset(head, 0, sizeof(linkNode));
	return head;
}

linkNode* createNode(Data val)
{
	linkNode* newNode = malloc(sizeof(linkNode));
	if (!newNode)
	{
		printf("newNode malloc falied"); 
        return NULL;
	}
	newNode->data = val;
	newNode->next = NULL;
	return newNode;
}

void pushfront(linkNode* list, Data val)
{
	linkNode* newNode = createNode(val);
	newNode->next = list->next;
	list->next = newNode;
}

void push_back(linkNode* list, Data val)
{
	linkNode* newNode = createNode(val);
	linkNode* cur = list;
	while (cur->next)
	{
		cur = cur->next;
	}
	cur->next = newNode;
}

void insert_pos(linkNode* list, int pos, Data val)
{
	linkNode* cur = list;
	linkNode* newNode = createNode(val);

	while (pos-- && cur->next)
	{
		cur = cur->next;
	}

	newNode->next = cur->next;
	cur->next = newNode;
}

void insert_item(linkNode* list, linkNode* item, Data val)
{
	linkNode* newNode = createNode(val);
	newNode->next = item->next;
	item->next = newNode;
}

linkNode* find(linkNode* list, Data val)
{
	linkNode* curNode = list->next; while (curNode)
	{

		if (curNode->data == val)
		{
			return curNode;
		}
		curNode = curNode->next;
	
	return NULL;

}

void pop_front(linkNode* list)
{
	linkNode* temp = list->next;
	list->next = list->next->next;
	free(temp);
}

void pop_back(linkNode* list)
{
	linkNode* cur = list;
	linkNode* temp = NULL;
	while (cur->next && cur->next->next)
	{

		cur = cur->next;
	}
	free(cur->next);
	cur->next = NULL;
}

void removeOne(linkNode* list, Data val)
{
	if (isempty(list))
		return;
	linkNode* cur = list;
	while (cur->next)
	{
		if (cur->next->data == val)
		{
			break;
		}
		cur = cur->next;
	}
	//删除
	if (cur->next)
	{
		linkNode* temp = cur->next;
		cur->next = cur->next->next;
		free(temp);
	}
}

void removeA1l(linkNode* list, Data val)
{
	if (isempty(list))
		return;
	linkNode* cur = list;
	linkNode* temp = NULL;
	while (cur->next)
	{
		if (cur->next->data == val)
		{
			temp = cur->next;
			cur->next = temp->next;
			free(temp);
			temp = NULL;
		}
		else
		{
			cur = cur->next;
		}

	}
}

bool isempty(linkNode* list)
{
	return list->next == NULL;
}

void show_list(linkNode* list)
{
	linkNode* cur = list->next;
	while (cur)
	{
		printf("%d ", cur->data);
		cur = cur->next;
	}
	printf("\n");
}
```

```c
#include <stdio.h>
#include "LinkList.h"


int main(void)
{
	linkNode* list = createList();
	pushfront(list, 1);
	pushfront(list, 3);
	pushfront(list, 2);
	pushfront(list, 3);
	pushfront(list, 3);

	insert_pos(list, 3, 2);
	//insert_pos(list, 3, 999);

	//linkNode* item = find(list, 3);
	//if (item)
	//{
	//	insert_item(list, item, 444);
	//}



	//pop_front(list);
	//pop_back(list);
	//	removeOne(list, 2);
	removeA1l(list, 2);
	show_list(list);
	while (1);
	return 0;
}
```

遍历

```c++
ListNode *cur = head;
int re = 0;
while (cur)
{
	cout << cur->val;
  	cur = cur->next;
}
```



# 进位

## [两数相加](https://leetcode.cn/problems/add-two-numbers/)

思路:  返回在一个新的链表, 处理好进位

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) 
    {
        // 哨兵节点
        ListNode* dummy = new ListNode(-1); 
        ListNode* cur = dummy;
        
        //
        int sum = 0;     //每个位的加和结果
        bool carry = false; //进位标志
        while(l1 != NULL || l2 != NULL)
        {
            sum=0;
            if(l1 != NULL)
            {
                sum += l1->val;
                l1 = l1->next;
            }
            if(l2 != NULL)
            {
                sum += l2->val;
                l2 = l2->next;
            }
            if(carry)
                sum++;
            cur->next  = new ListNode(sum % 10);  //个位
            cur= cur->next;
            carry = sum >= 10 ? true : false;  //进位
        }

        if(carry)
            cur->next  = new ListNode(1);
        return dummy->next;
    }
};
```

## [1290. 二进制链表转整数](https://leetcode.cn/problems/convert-binary-number-in-a-linked-list-to-integer/)

给你一个单链表的引用结点 `head`。链表中每个结点的值不是 0 就是 1。已知此链表是一个整数数字的二进制表示形式。

请你返回该链表所表示数字的 **十进制值** 。

 

**示例 1：**

![img](链表.assets/graph-1.png)

```
输入：head = [1,0,1]
输出：5
解释：二进制数 (101) 转化为十进制数 (5)
```

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    int getDecimalValue(ListNode* head) {
        ListNode *tmp = head;
        int re = 0;
        /*
        while (cur) {
            ans = ans * 2 + cur->val;
            cur = cur->next;
        }*/
        while (tmp) 
        {
            re = (re << 1) | (tmp->val);  //二进制转十进制
            tmp = tmp->next;
        }

        return re;
    }
};
```

r进制转10进制模版:

```c++
int Atoi(string s,int radix)    //s是给定的radix进制字符串
{
	int ans=0;
	for(int i=0;i<s.size();i++)
	{
		char t=s[i];
		if(t >= '0'&& t <= '9') 
            ans = ans * radix + t - '0'; // 字符转数字
		else
        {
            ans = ans * radix + t -'a' + 10;  //字符转数字
        } 
	}
	return ans;
}
```



# 使用虚拟节点

例如设置一个虚拟节点，移除元素1

![203_链表删除元素6](链表.assets/1631933200-HCPyhs-file_1631933200194.png)

给链表添加一个虚拟头结点为新的头结点，此时要移除这个旧头结点元素1。这样就其他节点的方式统一了。

## 使用哨兵节点

<font  color = red>使用虚拟节点处理 </font>

+ 操作头结点

+ 返回新链表

```c++
LinkNode* dummyHead = new LinkNode(0); // 如果没有创建哨兵就这样创建
LinkNode* cur = dummyHead;

// 有虚拟节点 cur->next 使用   // 无虚拟节点 cur 使用
// dummyHead->next 为真的头节点
```



### [203. 移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/)

给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。

**示例 1：**

![img](链表.assets/removelinked-list.jpg)

```
输入：head = [1,2,6,3,4,5,6], val = 6
输出：[1,2,3,4,5]
```

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution 
{
public:
    ListNode* removeElements(ListNode* head, int val) 
    {   
        ListNode *dummyHead = new ListNode(0);
        dummyHead->next = head;
        ListNode * cur = dummyHead;   // 虚拟头节点
        
        while (cur->next)
        {
            if (cur->next->val == val)
            {
                ListNode *temp = cur->next;
                cur->next = cur->next->next;
                delete temp;
            }
            else 
                cur = cur->next;
        }
        
        // 删除虚拟头节点
        head = dummyHead->next;
        delete dummyHead;
        return head;
    }
};
```

### [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

**示例 1：**

![img](链表.assets/merge_ex1.jpg)

```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */

class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) 
    {
        ListNode* dummyHead = new ListNode(-1); //动态创建哑节点，值为-1 
        ListNode* cur = dummyHead; //成为新的头节点,真链表的头节点就dummyHead->next //head节点也有prev指针了,这里可以保持头不变
        while (l1 && l2)   
        {
            if (l1->val < l2->val) 
            {
                cur->next = l1;
                l1 = l1->next;   // 更新位置
            } 
            else 
            {
                cur->next = l2;
                l2 = l2->next;
            }
            cur = cur->next;  //更新pre的位置. 
        }
        cur->next = l1 ? l1 : l2;
        return dummyHead->next;
    }
};
```

### 删除重复节点

[83. 删除排序链表中的重复元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/solutions/680623/tong-yong-shan-chu-zhong-fu-jie-dian-lia-101c/)

[83. 删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/)

给定一个已排序的链表的头 `head` ， *删除所有重复的元素，使每个元素只出现一次* 。返回 *已排序的链表* 。

**示例 1：**

<img src="链表.assets/list1.jpg" alt="img" style="zoom:33%;" />

```
输入：head = [1,1,2]
输出：[1,2]
```



```c++
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if(!head) 
            return nullptr;

        ListNode* dummyHead = new ListNode(109);
        ListNode* cur = dummyHead;
        
        while(head)
        {
            if(cur->val != head->val)
            {
                cur->next = head;
                cur = cur->next;
            }
            head = head->next;
        }
        cur->next = nullptr;
        return dummyHead->next;
    }
};
```

# 不使用虚拟节点

==无虚拟节点使用cur==

## [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

思路

      1. 设置temp
      2. 反转操作
      3. 更新

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * }; 
// 单链表
// 返回反转后的链表  
 */
class Solution 
{
public:
    ListNode* reverseList(ListNode* head) 
    {   
        ListNode* cur = head;
        ListNode* pre = nullptr;
        ListNode* temp;
        
        while (cur)
        {
            temp = cur->next; // 反转后找不到原来 cur的下一个位置
            cur->next = pre;  // 反转操作
            pre = cur;  // 更新pre位置
            cur = temp; // 更新cur位置
        }
        
        return pre;
    }
};
```



# 双指针

**获取倒数第k个元素，获取中间位置的元素，判断链表是否存在环，判断环的长度等和长度与位置有关的问题**。这些问题都可以通过灵活运用双指针来解决。

Tips：双指针并不是固定的公式，而是一种思维方式~

## 倒数第k个元素的问题

设有两个指针 p 和 q，初始时均指向头结点。首先，先让 p 沿着 next 移动 k 次。此时，p 指向第 k+1个结点，q 指向头节点，**两个指针的距离为 k** 。然后，同时移动 p 和 q，直到 p 指向空，此时 q 即指向倒数第 k 个结点。

![移动过程中保持距离为 k ](链表.assets/8fc9ef022554d2a062db6a70d5199dbbb2a154ba1e64f0f697319bb0ef9ac680.png)

```c++
class Solution {
public:
    ListNode* getKthFromEnd(ListNode* head, int k) {
        ListNode * fast = head;//初始化  // =head就相当于数组中=0
        ListNode * slow = head;
        while(k--) 
        {   //将 fast指针移动 k 次
            fast = fast->next; 
        }
        while(fast != nullptr) {//同时移动，直到 fast == nullptr
            fast = fast->next;
            slow = slow->next;
        }
        return slow;
    }
};
```

## 获取中间元素的问题

设有两个指针 fast 和 slow，初始时指向头节点。每次移动时，fast向后走两次，slow向后走一次，直到 fast 无法向后走两次。这使得在每轮移动之后。fast 和 slow 的距离就会增加一。设链表有 n 个元素，那么最多移动 n/2 轮。当 n 为奇数时，slow 恰好指向中间结点，当 n 为 偶数时，slow 恰好指向中间两个结点的靠前一个(可以考虑下如何使其指向后一个结点呢？)。下述代码实现了 n 为偶数时慢指针指向靠后结点。

总结快慢指针的特性 —— 每轮移动之后两者的距离会加一。

![快慢指针](链表.assets/7984572cea859a3d569932934fe6580abf3f59221ec95911f662f1f19b6822aa.png)

```c++
class Solution {
public:
    ListNode* middleNode(ListNode* head)
    {
        ListNode * fast = head;
        ListNode * slow = head;
       
        while(fast != nullptr && fast->next != nullptr) 
        {
            fast = fast->next->next;
            slow = slow->next;
        }
        return slow;
    } 
};
```

## 是否存在环的问题

如果将尾结点的 next 指针指向其他任意一个结点，那么链表就存在了一个环。

![一个有环的链表](链表.assets/ea4aff71116d6c483b2b34519497d39d640435cb3ce12ea1b40dd453c45b59fd.png)

快慢指针的特性 —— 每轮移动之后两者的距离会加一。 当一个链表有环时，快慢指针都会陷入环中进行无限次移动，然后变成了追及问题。想象一下在操场跑步的场景，只要一直跑下去，快的总会追上慢的。当两个指针都进入环后，每轮移动使得慢指针到快指针的距离增加一，同时快指针到慢指针的距离也减少一，只要一直移动下去，快指针总会追上慢指针。

![快慢指针在环上追及](链表.assets/d1ac82780e5189d7d58406504c3b7b56c35165997bfbb4c325677af92ee2d483.gif)

根据上述表述得出，如果一个链表存在环，那么快慢指针必然会相遇。实现代码如下：

```c++
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode *slow = head;
        ListNode *fast = head;
        
        while(fast != nullptr) 
        {
            fast = fast->next;
            if(fast != nullptr) 
                fast = fast->next;
           
            if(fast == slow) 
                return true;
         
            slow = slow->next;
        }
        return nullptr;
    }
};
```

最后一个问题，如果存在环，如何判断环的长度呢？方法是，快慢指针相遇后继续移动，直到第二次相遇。两次相遇间的移动次数即为环的长度。

## [876. 链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list/)

给你单链表的头结点 `head` ，请你找出并返回链表的中间结点。

如果有两个中间结点，则返回第二个中间结点。

 

**示例 1：**

![img](链表.assets/lc-midlist1.jpg)

输入：head = [1,2,3,4,5]
输出：[3,4,5]
解释：链表只有一个中间结点，值为 3 。



```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution 
{
public:
    ListNode* middleNode(ListNode* head) 
    {// 快慢指针
        ListNode * fast = head;
        ListNode * slow = head;
        while (fast && fast->next)
        {
            fast = fast->next->next;
            slow = slow->next;
        }
        return slow;
    }
};
```







## [141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)

给你一个链表的头节点 `head` ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。**注意：`pos` 不作为参数进行传递** 。仅仅是为了标识链表的实际情况。

*如果链表中存在环* ，则返回 `true` 。 否则，返回 `false` 

 

**示例 1：**

![img](链表.assets/circularlinkedlist.png)

```
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```



```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution 
{
public:
    bool hasCycle(ListNode *head) 
    {
        ListNode * slow = head;
        ListNode * fast = head;
        while (fast && fast->next)
        {
            slow = slow->next;
            fast = fast->next->next;
            if (slow == fast)
                return true;
        }
        return false;
    }
};
```





[160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)



给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null` 。

图示两个链表在节点 `c1` 开始相交**：**

[![img](链表.assets/160_statement.png)](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)

题目数据 **保证** 整个链式结构中不存在环。

**注意**，函数返回结果后，链表必须 **保持其原始结构** 。

**自定义评测：**

**评测系统** 的输入如下（你设计的程序 **不适用** 此输入）：

- `intersectVal` - 相交的起始节点的值。如果不存在相交节点，这一值为 `0`
- `listA` - 第一个链表
- `listB` - 第二个链表
- `skipA` - 在 `listA` 中（从头节点开始）跳到交叉节点的节点数
- `skipB` - 在 `listB` 中（从头节点开始）跳到交叉节点的节点数

评测系统将根据这些输入创建链式数据结构，并将两个头节点 `headA` 和 `headB` 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 **视作正确答案** 。

 

**示例 1：**

[![img](链表.assets/160_example_1_1.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png)

```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
输出：Intersected at '8'
解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。
```



```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution 
{
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) 
    {
        ListNode* curA = headA;
        ListNode* curB = headB;
        int lenA = 0, lenB = 0;
        while (curA)
        {
            lenA++;
            curA = curA->next;
        }
        while (curB)
        {
            lenB++;
            curB = curB->next;
        }
        curA = headA;
        curB = headB;
        if (lenB > lenA)
        {
            swap(curA, curB);
            swap(lenA, lenB);
        }
        int diff = lenA - lenB;
        while(diff--)
        {
            curA = curA->next;
        }
        while (curA)
        {
            if (curA == curB)
                return curB;
            curA = curA->next;
            curB = curB->next;
        }
        return NULL;
    }
};
```





[234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/)

给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。

 

**示例 1：**

![img](链表.assets/pal1linked-list.jpg)

```
输入：head = [1,2,2,1]
输出：true
```



```c++
class Solution 
{
 public: 

    bool isPalindrome(ListNode* head) 
    {
        if(!head || !head->next) 
        {
            return true;
        }
        ListNode *slow = head, *fast = head;
        ListNode *pre = NULL;
        while(fast && fast->next) 
        {
            fast = fast->next->next;
            // 反转链表 
            ListNode *temp = slow->next;
            slow->next = pre;
            pre = slow;
            slow = temp;
        }
        if(fast) 
        {
            slow = slow->next;
        }
        while(pre && slow) 
        {
            if(pre->val != slow->val) 
            {
                return false;
            }
            pre = pre->next;
            slow = slow->next;
        }
        return true;
    }
};
```





[面试题 02.07. 链表相交](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)



给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 `null` 。

图示两个链表在节点 `c1` 开始相交**：**

[![img](链表.assets/160_statement-169262560326210.png)](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)

题目数据 **保证** 整个链式结构中不存在环。

**注意**，函数返回结果后，链表必须 **保持其原始结构** 。

 

**示例 1：**

[![img](链表.assets/160_example_1.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png)

```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Intersected at '8'
解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
```



```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
        // 给你两个单链表的头节点 headA 和 headB 
        //返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null
        // 相当于返回第一个公共的那个元素. 起始
        // 就是求两个链表交点节点的指针。交点不是数值相等，而是指针相等
class Solution 
{
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) 
    {
        ListNode* curA = headA;
        ListNode* curB = headB;
        int lenA = 0, lenB = 0;
        while (curA)
        {
            lenA++;
            curA = curA->next;
        }
        while (curB)
        {
            lenB++;
            curB = curB->next;
        }
        curA = headA;
        curB = headB;
        // 默认人curA是最长的那个
        if (lenA < lenB)
        {
            swap(lenA, lenB);  // 交换数据
            swap(curA, curB);
        }
        int diff = lenA - lenB;
        // curA和curB同起点,末尾部分都对齐
        while (diff--)
        {
            curA = curA->next;
        }
        //找交点
        while (curA)
        {
            if (curA == curB) //找的是节点而非值
            {
                return curA;
            }
            curA = curA->next;
            curB = curB->next;
        }
        return nullptr;
    }
};
```



# 数组与链表

## 数组

作为线性表的两种存储方式 —— 链表和数组

数组，所有元素都连续的存储于一段内存中，且每个元素占用的内存大小相同。这使得数组具备了通过下标快速访问数据的能力。 但连续存储的缺点也很明显，增加容量，增删元素的成本很高，时间复杂度均为 O(n)。 增加数组容量需要先申请一块新的内存，然后复制原有的元素。如果需要的话，可能还要删除原先的内存。

![数组扩容](链表.assets/d459210b7772b9c4eb53c9f149605e8383b3da3f062b2cdbdb8fb176b7723414.gif)



删除元素时需要移动被删除元素之后的所有元素以保证所有元素是连续的。增加元素时需要移动指定位置及之后的所有元素，然后将新增元素插入到指定位置，如果容量不足的话还需要先进行扩容操作。

![数组删除元素](链表.assets/569968eade195df95d9eece82c6eb86ff060c52fc4a473fe2c713c544382618b.gif)

总结一下数组的优缺点：

+ 优点：可以根据偏移实现快速的随机读写。
+ 缺点：扩容，增删元素极慢。

## 链表

<font color=red>无法高效获取长度，无法根据偏移快速访问元素</font>

链表，由若干个结点组成，每个结点包含数据域和指针域。结点结构如下图所示：

![链表的一个结点](链表.assets/c7d108c97c0ca74cff6dfab1768afb586e9313e77b31ffd1b1db67c9c0855a4e.png)

一般来讲，链表中只会有一个结点的指针域为空，该结点为**尾结点**，其他结点的指针域都会存储一个结点的内存地址。链表中也只会有一个结点的内存地址没有存储在其他结点的指针域，该结点称为**头结点**。

![内存中的链表](链表.assets/a08a48ef802cd06bb5c666f9cf76994223a5e4404262bf3dd3ffe668bba7b0b3.png)

链表的存储方式使得它可以**高效的在指定位置插入与删除**，时间复杂度均为 O(1)。 在结点 p 之后增加一个结点 q 总共分三步：

1. 申请一段内存用以存储 q (可以使用内存池避免频繁申请和销毁内存)。
2. 将 p 的指针域数据复制到 q 的指针域。
3. 更新 p 的指针域为 q 的地址。

删除结点 p 之后的结点 q 总共分两步：

+ 将 q 的指针域复制到 p 的指针域。
+ 释放 q 结点的内存。

## 链表的主要代码

```c++
#include <bits/stdc++.h>

using namespace std;

//定义一个结点模板
template<typename T>
struct Node {
	T data;
	Node *next;
	Node() : next(nullptr) {}
	Node(const T &d) : data(d), next(nullptr) {}
};

//删除 p 结点后面的元素
template<typename T>
void Remove(Node<T> *p) {
	if (p == nullptr || p->next == nullptr) {
		return;
	}
	auto tmp = p->next->next;
	delete p->next;
	p->next = tmp;
}

//在 p 结点后面插入元素
template<typename T>
void Insert(Node<T> *p, const T &data) {
	auto tmp = new Node<T>(data);
	tmp->next = p->next;
	p->next = tmp;
}

//遍历链表
template<typename T, typename V>
void Walk(Node<T> *p, const V &vistor) {
	while(p != nullptr) {
		vistor(p);
		p = p->next;
	}
}

int main() {
	auto p = new Node<int>(1);
	Insert(p, 2);
	int sum = 0;
	Walk(p, [&sum](const Node<int> *p) -> void { sum += p->data; });
	cout << sum << endl;
	Remove(p);
	sum = 0;
	Walk(p, [&sum](const Node<int> *p) -> void { sum += p->data; });
	cout << sum << endl;
	return 0;
}
```





